#pragma once

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
  extern "C" {
#endif

// TODO: Export to avoid unused function errors with -Werror.
// Remove. Have parser count type usage and only include the code if required.
int write_raw_little_endian32(uint32_t value, uint8_t *buffer, int offset);
int write_raw_little_endian64(uint64_t value, uint8_t *buffer, int offset);
int write_raw_float(float value, uint8_t *buffer, int offset);
int write_raw_double(double value, uint8_t *buffer, int offset);
int write_raw_varint32(uint32_t value, uint8_t *buffer, int offset);
int write_raw_varint64(uint64_t value, uint8_t *buffer, int offset);
int read_raw_little_endian32(uint32_t *tag, const uint8_t *buffer, int offset);
int read_raw_little_endian64(uint64_t *tag, const uint8_t *buffer, int offset);
int read_raw_float(float *tag, const uint8_t *buffer, int offset);
int read_raw_double(double *tag, const uint8_t *buffer, int offset);
int read_raw_varint32(uint32_t *tag, const uint8_t *buffer, int offset);
int read_raw_varint64(uint64_t *tag, const uint8_t *buffer, int offset);

<% each do |exp| %>
  <% if exp.kind_of?(Protobuf::Generate::Ast::Enum) %>

  typedef enum {
    <% exp.fields.each do |field| %>
      <%= constant exp.package, exp.name, field.name %> = <%= field.tag %>,
    <% end %>
  } <%= type exp.package, exp.name %>;
  <% elsif exp.kind_of?(Protobuf::Generate::Ast::Message) %>

  typedef struct <%= type exp.package, exp.name %> {
    <% exp.fields.each do |field| %>
      <% if type_message?(field.type) %>
        <%= type exp.package, field.type %> <%= field.name %>;
      <% elsif type_enum?(field.type) %>
        <%= type exp.package, field.type %> <%= field.name %>;
      <% elsif field.type =~ /double/ %>
        double <%= field.name %>;
      <% elsif field.type =~ /float/ %>
        float <%= field.name %>;
      <% elsif field.type =~ /int32|sint32|sfixed32/ %>
        int32_t <%= field.name %>;
      <% elsif field.type =~ /int64|sint64|sfixed64/ %>
        int64_t <%= field.name %>;
      <% elsif field.type =~ /uint32|fixed32/ %>
        uint32_t <%= field.name %>;
      <% elsif field.type =~ /uint64|fixed64/ %>
        uint64_t <%= field.name %>;
      <% elsif field.type =~ /bool/ %>
        bool <%= field.name %>;
      <% elsif field.type =~ /string/ %>
        struct {
          uint8_t data[<%= field.meta["size_max"] %>];
          size_t  size;
        } <%= field.name %>;
      <% elsif field.type =~ /bytes/ %>
        struct {
          uint8_t data[<%= field.meta["size_max"] %>];
          size_t  size;
        } <%= field.name %>;
      <% end %>
    <% end %>
  } <%= type exp.package, exp.name %>;

  // TODO: Replace int with an protobuf_(encode|decode)_t type.
  // TODO: Move encode_size into result type.
  int <%= function exp.package, exp.name, 'encode' %>(const <%= type exp.package, exp.name %> *pb, uint8_t *data, size_t data_size, size_t *encoded_size);
  int <%= function exp.package, exp.name, 'decode' %>(<%= type exp.package, exp.name %> *pb, const uint8_t *data, size_t data_size, size_t *encoded_size);
  <% end %>
<% end %>

#ifdef __cplusplus
  }
#endif
