#include TODO:

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

int write_raw_byte(char value, void *_buffer, int offset) {
  *((char *)_buffer + offset) = value;
  return ++offset;
}

int write_raw_little_endian32(uint32_t value, void *_buffer, int offset) {
  offset = write_raw_byte((char)((value      ) & 0xFF), _buffer, offset);
  offset = write_raw_byte((char)((value >>  8) & 0xFF), _buffer, offset);
  offset = write_raw_byte((char)((value >> 16) & 0xFF), _buffer, offset);
  offset = write_raw_byte((char)((value >> 24) & 0xFF), _buffer, offset);
  return offset;
}

int write_raw_little_endian64(uint64_t value, void *_buffer, int offset) {
  offset = write_raw_byte((char)((value      ) & 0xFF), _buffer, offset);
  offset = write_raw_byte((char)((value >>  8) & 0xFF), _buffer, offset);
  offset = write_raw_byte((char)((value >> 16) & 0xFF), _buffer, offset);
  offset = write_raw_byte((char)((value >> 24) & 0xFF), _buffer, offset);
  offset = write_raw_byte((char)((value >> 32) & 0xFF), _buffer, offset);
  offset = write_raw_byte((char)((value >> 40) & 0xFF), _buffer, offset);
  offset = write_raw_byte((char)((value >> 48) & 0xFF), _buffer, offset);
  offset = write_raw_byte((char)((value >> 56) & 0xFF), _buffer, offset);
  return offset;
}

int write_raw_varint32(uint32_t value, void *_buffer, int offset) {
  while (1) {
    if ((value & ~0x7F) == 0) {
      offset = write_raw_byte((char)value, _buffer, offset);
      return offset;
    } else {
      offset = write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
      value  = value >> 7;
    }
  }
  return offset;
}

int write_raw_varint64(uint64_t value, void *_buffer, int offset) {
  while (1) {
    if ((value & ~0x7FL) == 0) {
      offset = write_raw_byte((char)value, _buffer, offset);
      return offset;
    } else {
      offset = write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
      value  = value >> 7;
    }
  }
  return offset;
}

int write_raw_bytes(char *bytes, int bytes_size, void *_buffer, int offset) {
  for (int i = 0; i < bytes_size; ++i)
    offset = write_raw_byte((char)*(bytes + i), _buffer, offset);
  return offset;
}

uint32_t encode_zig_zag32(int32_t n) {
  return (n << 1) ^ (n >> 31);
}

uint64_t encode_zig_zag64(int64_t n) {
  return (n << 1) ^ (n >> 63);
}

int32_t decode_zig_zag32(uint32_t n) {
  return (n >> 1) ^ -(n & 1);
}

int64_t decode_zig_zag64(uint64_t n) {
  return (n >> 1) ^ -(n & 1);
}

int read_raw_byte(char *tag, void *_buffer, int offset) {
  *tag = *((char *) _buffer + offset);
  return ++offset;
}

int read_raw_little_endian32(uint32_t *tag, void *_buffer, int offset) {
  offset = read_raw_byte((char *)tag, _buffer, offset);
  char b1 = (char) *tag;
  offset = read_raw_byte((char *)tag, _buffer, offset);
  char b2 = (char) *tag;
  offset = read_raw_byte((char *)tag, _buffer, offset);
  char b3 = (char) *tag;
  offset = read_raw_byte((char *)tag, _buffer, offset);
  char b4 = (char) *tag;

  *tag = (((uint32_t)b1 & 0xff)      ) |
         (((uint32_t)b2 & 0xff) <<  8) |
         (((uint32_t)b3 & 0xff) << 16) |
         (((uint32_t)b4 & 0xff) << 24);
  return offset;
}

int read_raw_little_endian64(uint64_t *tag, void *_buffer, int offset) {
  offset = read_raw_byte((char *)tag, _buffer, offset);
  char b1 = (char) *tag;
  offset = read_raw_byte((char *)tag, _buffer, offset);
  char b2 = (char) *tag;
  offset = read_raw_byte((char *)tag, _buffer, offset);
  char b3 = (char) *tag;
  offset = read_raw_byte((char *)tag, _buffer, offset);
  char b4 = (char) *tag;
  offset = read_raw_byte((char *)tag, _buffer, offset);
  char b5 = (char) *tag;
  offset = read_raw_byte((char *)tag, _buffer, offset);
  char b6 = (char) *tag;
  offset = read_raw_byte((char *)tag, _buffer, offset);
  char b7 = (char) *tag;
  offset = read_raw_byte((char *)tag, _buffer, offset);
  char b8 = (char) *tag;

  *tag = (((uint64_t)b1 & 0xff)      ) |
         (((uint64_t)b2 & 0xff) <<  8) |
         (((uint64_t)b3 & 0xff) << 16) |
         (((uint64_t)b4 & 0xff) << 24) |
         (((uint64_t)b5 & 0xff) << 32) |
         (((uint64_t)b6 & 0xff) << 40) |
         (((uint64_t)b7 & 0xff) << 48) |
         (((uint64_t)b8 & 0xff) << 56);

  return offset;
}

int read_raw_varint32(uint32_t *tag, void *_buffer, int offset) {
  signed char result;

  offset = read_raw_byte((char *)&result, _buffer, offset);
  if (result >= 0) {
    *tag = result;
    return offset;
  }
  *tag = result & 0x7f;
  offset = read_raw_byte((char *)&result, _buffer, offset);
  if (result >= 0) {
    *tag |= result << 7;
  } else {
    *tag |= (result & 0x7f) << 7;
    offset = read_raw_byte((char *)&result, _buffer, offset);
    if (result >= 0) {
      *tag |= result << 14;
    } else {
      *tag |= (result & 0x7f) << 14;
      offset = read_raw_byte((char *)&result, _buffer, offset);
      if (result >= 0) {
        *tag |= ((uint32_t)result) << 21;
      } else {
        *tag |= (((uint32_t)result) & 0x7f) << 21;
        offset = read_raw_byte((char *)&result, _buffer, offset);
        *tag |= ((uint32_t)result) << 28;
        if (result < 0) {
          /* Discard upper 32 bits. */
          int i;
          for (i = 0; i < 5; ++ i) {
            offset = read_raw_byte((char *)&result, _buffer, offset);
            if (result >= 0) {
              return offset;
            }
          }
          /* Invalid state. */
        }
      }
    }
  }
  return offset;
}

int read_raw_varint64(uint64_t *tag, void *_buffer, int offset) {
  short shift = 0;
  signed char b;
  *tag = 0;
  while (shift < 64) {
    offset = read_raw_byte((char *)&b, _buffer, offset);
    *tag |= (uint64_t)(b & 0x7F) << shift;
    if ((b & 0x80) == 0) {
      return offset;
    }
    shift += 7;
  }
  /* return error code. */
  return -1;
}

<% each do |exp| %>
  <%
    if exp.kind_of?(Protobuf::Generate::Ast::Package)
      package exp.name
    elsif exp.kind_of?(Protobuf::Generate::Ast::Enum)
  %>
  <% elsif exp.kind_of?(Protobuf::Generate::Ast::Message) %>

  void <%= namespaced_function exp.name, 'clear' %>(<%= namespaced_type exp.name %> *_pb) {
    memset(_pb, 0, sizeof(*_pb));
  }

  void <%= namespaced_function exp.name, 'init', 'optional', 'attributes' %>(<%= namespaced_type exp.name %> *_pb) {
    <% exp.fields.each do |field| %>
      <% if field.optional? %>
        <% if type_message?(field.type) %>
          <%= namespaced_function field.type, 'init', 'optional', 'attributes' %>(&_pb-><%= field.name %>);
        <% elsif type_enum?(field.type) %>
          _pb-><%= field.name %> = <%= namespaced_constant field.type, type_enum_default(field.type, field.options.fetch('default', nil)) %>;
        <% elsif field.type =~ /bool/ %>
          _pb-><%= field.name %> = <%= field.options.fetch(:default, 'false') %>;
        <% elsif field.type =~ /string|bytes/ %>
          _pb-><%= field.name %>.data = <%= field.options.fetch('default', '""') %>;
          _pb-><%= field.name %>.size = <%= field.options.fetch('default', '').bytesize %>;
        <% else %>
          _pb-><%= field.name %> = <%= field.options.fetch('default', 0) %>;
        <% end %>
      <% end %>
    <% end %>
  }

  bool <%= namespaced_function exp.name, 'is', 'default', 'message' %>(<%= namespaced_type exp.name %> _*pb) {
    return true
    <% exp.fields.each do |field| %>    // <%= field.name %>
      <% if type_message?(field.type) %>
        && <%= namespaced_function field.type, 'is', 'default', 'message' %>(&_pb-><%= field.name %>)
      <% elsif type_enum?(field.type) %>
        _pb-><%= field.name %> == <%= namespaced_constant field.type, type_enum_default(field.type, field.options.fetch('default', nil)) %>
      <% elsif field.type =~ /string|bytes/ %>
        && memcmp(&_pb-><%= field.name %>.data, <%= field.options.fetch('default', '""') %>, <%= field.meta.fetch('size_max', field.options.fetch('default', '').bytesize) %>) == 0
        && _pb-><%= field.name %>.size == <%= field.options.fetch('default', '').bytesize %>
      <% else %>
        && _pb-><%= field.name %> == <%= field.options.fetch('default', 0) %>
      <% end %>
    <% end %>;
  }

  int <%= namespaced_function exp.name, 'write' %>(<%= namespaced_type exp.name %> _*pb, void *_buffer, int offset) {
    <% exp.fields.each do |field| %>      // <%= field.name %>
      <% if field.optional? %>
        <% if type_message?(field.type) %>
          if (!<%= namespaced_function field.type, 'is', 'default', 'message' %>(&_pb-><%= field.name %>)) {
            offset = <%= namespaced_function field.type, 'write', 'with', 'tag' %>(&_pb-><%= field.name %>, _buffer, offset, <%= field.tag %>);
          }
        <% elsif type_enum?(field.type) %>
          if (_pb-><%= field.name %> != <%= namespaced_constant field.type, type_enum_default(field.type, field.options.fetch('default', nil)) %>) {
            offset = <%= namespaced_function field.type, 'write', 'with', 'tag' %>(&_pb-><%= field.name %>, _buffer, offset, <%= field.tag %>);
          }
        <% elsif field.type =~ /double/ %>
          if (_pb-><%= field.name %> != <%= field.options.fetch('default', 0) %>) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            offset = write_raw_little_endian64(*(uint64_t *)&_pb-><%= field.name %>, _buffer, offset);
          }
        <% elsif field.type =~ /float/ %>
          if (_pb-><%= field.name %> != <%= field.options.fetch('default', 0) %>) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            offset = write_raw_little_endian32(*(uint32_t *)&_pb-><%= field.name %>, _buffer, offset);
          }
        <% elsif field.type =~ /int32/%>
          if (_pb-><%= field.name %> != <%= field.options.fetch('default', 0) %>) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            if (_pb-><%= field.name %> >= 0) offset = write_raw_varin32(_pb-><%= field.name %>, _buffer, offset);
            else offset = write_raw_varint64(_pb-><%= field.name %>, _buffer, offset);
          }
        <% elsif field.type =~ /int64/ %>
          if (_pb-><%= field.name %> != <%= field.options.fetch('default', 0) %>) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            offset = write_raw_varint64(_pb-><%= field.name %>, _buffer, offset);
          }
        <% elsif field.type =~ /sint32/ %>
          if (_pb-><%= field.name %> != <%= field.options.fetch('default', 0) %>) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            offset = write_raw_varint32(encode_zig_zag32(_pb-><%= field.name %>), _buffer, offset);
          }
        <% elsif field.type =~ /sint62/ %>
          if (_pb-><%= field.name %> != <%= field.options.fetch('default', 0) %>) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            offset = write_raw_varint64(encode_zig_zag64(_pb-><%= field.name %>), _buffer, offset);
          }
        <% elsif field.type =~ /uint32/ %>
          if (_pb-><%= field.name %> != <%= field.options.fetch('default', 0) %>) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            offset = write_raw_varint32(_pb-><%= field.name %>, _buffer, offset);
          }
        <% elsif field.type =~ /uint64/ %>
          if (_pb-><%= field.name %> != <%= field.options.fetch('default', 0) %>) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            offset = write_raw_varint64(_pb-><%= field.name %>, _buffer, offset);
          }
        <% elsif field.type =~ /s?fixed32/ %>
          if (_pb-><%= field.name %> != <%= field.options.fetch('default', 0) %>) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            offset = write_raw_little_endian32(_pb-><%= field.name %>, _buffer, offset);
          }
        <% elsif field.type =~ /s?fixed64/ %>
          if (_pb-><%= field.name %> != <%= field.options.fetch('default', 0) %>) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            offset = write_raw_little_endian64(_pb-><%= field.name %>, _buffer, offset);
          }
        <% elsif field.type =~ /bool/ %>
          if (_pb-><%= field.name %> != <%= field.options.fetch('default', 'false') %>) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            offset = write_raw_byte(_pb-><%= field.name %>, _buffer, offset);
          }
        <% elsif field.type =~ /string/ %>
          if (memcmp(&_pb-><%= field.name %>.data, <%= field.options.fetch('default', '""') %>, <%= field.meta.fetch('size_max', field.options.fetch('default', '').bytesize) %>) != 0) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            offset = write_raw_varint32(_pb-><%= field.name %>.size, _buffer, offset);
            offset = write_raw_bytes(_pb-><%= field.name %>.data, _pb-><%= field.name %>.size, _buffer, offset);
          }
        <% elsif field.type =~ /bytes/ %>
          if (memcmp(&_pb-><%= field.name %>.data, <%= field.options.fetch('default', '""') %>, <%= field.meta.fetch('size_max', field.options.fetch('default', '').bytesize) %>) != 0) {
            offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
            offset = write_raw_varint32(_pb-><%= field.name %>.size, _buffer, offset);
            offset = write_raw_bytes(_pb-><%= field.name %>.data, _pb-><%= field.name %>.size, _buffer, offset);
          }
        <% end %>
      <% else %>
        <% if type_message?(field.type) %>
          offset = <%= namespaced_function field.type, 'write', 'with', 'tag' %>(&_pb-><%= field.name %>, _buffer, offset, <%= field.tag %>);
        <% elsif type_enum?(field.type) %>
          offset = <%= namespaced_function field.type, 'write', 'with', 'tag' %>(&_pb-><%= field.name %>, _buffer, offset, <%= field.tag %>);
        <% elsif field.type =~ /double/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          offset = write_raw_little_endian64(*(uint64_t *)&_pb-><%= field.name %>, _buffer, offset);
        <% elsif field.type =~ /float/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          offset = write_raw_little_endian32(*(uint32_t *)&_pb-><%= field.name %>, _buffer, offset);
        <% elsif field.type =~ /int32/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          if (_pb-><%= field.name %> >= 0) offset = write_raw_varin32(_pb-><%= field.name %>, _buffer, offset);
          else offset = write_raw_varint64(_pb-><%= field.name %>, _buffer, offset);
        <% elsif field.type =~ /int64/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          offset = write_raw_varint64(_pb-><%= field.name %>, _buffer, offset);
        <% elsif field.type =~ /sint32/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          offset = write_raw_varint32(encode_zig_zag32(_pb-><%= field.name %>), _buffer, offset);
        <% elsif field.type =~ /sint62/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          offset = write_raw_varint64(encode_zig_zag64(_pb-><%= field.name %>), _buffer, offset);
        <% elsif field.type =~ /uint32/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          offset = write_raw_varint32(_pb-><%= field.name %>, _buffer, offset);
        <% elsif field.type =~ /uint64/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          offset = write_raw_varint64(_pb-><%= field.name %>, _buffer, offset);
        <% elsif field.type =~ /s?fixed32/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          offset = write_raw_little_endian32(_pb-><%= field.name %>, _buffer, offset);
        <% elsif field.type =~ /s?fixed64/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          offset = write_raw_little_endian64(_pb-><%= field.name %>, _buffer, offset);
        <% elsif field.type =~ /bool/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          offset = write_raw_byte(_pb-><%= field.name %>, _buffer, offset);
        <% elsif field.type =~ /string/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          offset = write_raw_varint32(_pb-><%= field.name %>.size, _buffer, offset);
          offset = write_raw_bytes(_pb-><%= field.name %>.data, _pb-><%= field.name %>.size, _buffer, offset);
        <% elsif field.type =~ /bytes/ %>
          offset = write_raw_varint32((<%= field.tag %><<3)+<%= type_wire field.type %>, _buffer, offset);
          offset = write_raw_varint32(_pb-><%= field.name %>.size, _buffer, offset);
          offset = write_raw_bytes(_pb-><%= field.name %>.data, _pb-><%= field.name %>.size, _buffer, offset);
        <% end %>
      <% end %>
    <% end %>
    return offset;
  }

  int <%= namespaced_function exp.name, 'write', 'with', 'tag' %>(<%= namespaced_type exp.name %> *_pb, void *_buffer, int offset, int tag) {
      offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
      offset = <%= namespaced_function exp.name, 'write', 'delimited', 'to' %>(_pb, _buffer, offset);
      return offset;
  }

  int <%= namespaced_function exp.name, 'write', 'delimited', 'to' %>(<%= namespaced_type exp.name %> *_pb, void *_buffer, int offset) {
    int i, shift, new_offset, size;

    new_offset = <%= namespaced_function exp.name, 'write' %>(_pb, _buffer, offset);
    size       = new_offset - offset;
    shift      = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
      *((char *)_buffer + i + shift) = *((char *)_buffer + i);

    write_raw_varint32((uint32_t)size, _buffer, offset);
    return new_offset + shift;
  }

  int <%= namespaced_function exp.name, 'read' %>(<%= namespaced_type exp.name %> *_pb, void *_buffer, int offset, int limit) {
    <%= namespaced_function exp.name, 'clear' %>(_pb);
    <%= namespaced_function exp.name, 'init', 'optional', 'attributes' %>(_pb);

    uint32_t tag   = 0;
    while (offset < limit) {
      offset = read_raw_varint32(&tag, _buffer, offset);
      tag    = tag>>3;
      switch (tag) {
      <% exp.fields.each do |field| %>
      case <%= field.tag %>:
          // <%= field.name %>
        <% if type_message?(field.type) %>
          offset = <%= namespaced_function field.type, 'read', 'delimited', 'from' %>(&_pb-><%= field.name %>, _buffer, offset);
        <% elsif type_enum?(field.type) %>
          offset = read_raw_varint32(&tag, _buffer, offset);
          _pb-><%= field.name %> = tag;
        <% elsif field.type =~ /float/ %>
          offset = read_raw_little_endian32(&tag, _buffer, offset);
          _pb-><%= field.name %> = *(float *)(&tag);
        <% elsif field.type =~ /double/ %>
        {
          uint64_t value = 0;
          offset = read_raw_little_endian64(&value, _buffer, offset);
          _pb-><%= field.name %> = *(double *)(&value);
        }
        <% elsif field.type =~ /int32/ %>
          offset = read_raw_varint32(&tag, _buffer, offset);
          _pb-><%= field.name %> = (int32_t)tag;
        <% elsif field.type =~ /int64/ %>
        {
          uint64_t value = 0;
          offset = read_raw_varint64(&value, _buffer, offset);
          _pb-><%= field.name %> = (int64_t)tag;
        }
        <% elsif field.type =~ /sint32/ %>
          offset = read_raw_varint32(&tag, _buffer, offset);
          _pb-><%= field.name %> = decode_zig_zag32(tag);
        <% elsif field.type =~ /sint64/ %>
        {
          uint64_t value = 0;
          offset = read_raw_varint64(&value, _buffer, offset);
          _pb-><%= field.name %> = decode_zig_zag64(value);
        }
        <% elsif field.type =~ /uint32/ %>
          offset = read_raw_varint32(&tag, _buffer, offset);
          _pb-><%= field.name %> = tag;
        <% elsif field.type =~ /uint64/ %>
        {
          uint64_t value = 0;
          offset = read_raw_varint64(&value, _buffer, offset);
          _pb-><%= field.name %> = value;
        }
        <% elsif field.type =~ /fixed32/ %>
          offset = read_raw_little_endian32(&tag, _buffer, offset);
          _pb-><%= field.name %> = tag;
        <% elsif field.type =~ /fixed64/ %>
        {
          uint64_t value = 0;
          offset = read_raw_little_endian32(&value, _buffer, offset);
          _pb-><%= field.name %> = value;
        }
        <% elsif field.type =~ /sfixed32/ %>
          offset = read_raw_little_endian32(&tag, _buffer, offset);
          _pb-><%= field.name %> = (int32_t)tag;
        <% elsif field.type =~ /sfixed64/ %>
        {
          uint64_t value = 0;
          offset = read_raw_little_endian64(&value, _buffer, offset);
          _pb-><%= field.name %> = (int64_t)value;
        }
        <% elsif field.type =~ /bool/ %>
          offset = read_raw_varint32(&tag, _buffer, offset);
          _pb-><%= field.name %> = tag & 1;
        <% elsif field.type =~ /string|bytes/ %>
          offset = read_raw_varint32(&tag, _buffer, offset);
          _pb-><%= field.name %>.size = (size_t)tag;
          for (size_t i = 0; i < (size_t)tag; ++i)
            offset = read_raw_byte((_pb-><%= field.name %> + i), _buffer, offset);
        <% end %>
          break;
      <% end %>
      }
    }
    return offset;
  }

  int <%= namespaced_function exp.name, 'read', 'delimited', 'from' %>(<%= namespaced_type exp.name %> *_pb, void *_buffer, int offset) {
    size_t size;
    offset = read_raw_varint32(&size, _buffer, offset);
    <%= namespaced_function exp.name, 'read' %>(_pb, _buffer, size + offset);
    return offset + size;
  }

  int <%= namespaced_function exp.name, 'encode' %>(const <%= namespaced_type exp.name %> *pb, uint8_t *data, size_t data_size, size_t *encoded_size) {

  }

  int <%= namespaced_function exp.name, 'decode' %>(<%= namespaced_type exp.name %> *pb, const uint8_t *data, size_t data_size, size_t *encoded_size) {

  }
  <% end %>
<% end %>
